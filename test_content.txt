##-FOLDER-START-##
Начальный
##-TOPIC-START-##
Практическая работа №1: Информация. Объем информации. Единицы измерения информации.
Уровень: Начальный
Модуль 1. Основы информатики
#-SLIDE-START-#
TITLE:: 1. Цели и задачи выполнения практической работы
Цель: 
Сформировать у обучающихся практические навыки расчета информационного объема данных и перевода между различными единицами измерения информации.
Задачи:
- Закрепить понимание основных единиц измерения информации: бит, байт, килобайт, мегабайт, гигабайт.
- Научиться применять формулы для перевода единиц измерения информации.
- Отработать навык расчета информационного объема текстовых сообщений.
- Научиться применять полученные знания для решения практических задач, связанных с реальными объектами (файлами, изображениями).
#-SLIDE-START-#
TITLE:: 2. Краткое изложение теоретического материала
Бит — минимальная единица измерения информации, может принимать одно из двух значений: 0 или 1.
Байт — основная единица хранения и обработки цифровой информации, состоящая из 8 бит.
Основные соотношения единиц:
1 байт = 8 бит
1 Килобайт (КБ) = 1024 байт
1 Мегабайт (МБ) = 1024 КБ
1 Гигабайт (ГБ) = 1024 МБ
Перевод в меньшие единицы: Для перевода более крупной единицы в меньшую используется операция умножения.
Пример: 3 КБ = 3 * 1024 = 3072 байт.
Перевод в большие единицы: Для перевода меньшей единицы в большую используется операция деления.
Пример: 2048 байт = 2048 / 1024 = 2 КБ.
Информационный объем текста: При алфавитном подходе, если для кодирования одного символа используется 1 байт (8 бит), то информационный объем текста равен количеству символов, умноженному на 1 байт.
#-SLIDE-START-#
TITLE:: 3. Пошаговые методические указания по выполнению заданий
Задание 1: Решение задач на определение объема информации
Шаг 1: Внимательно прочтите условие задачи. Определите, какая величина известна, а какую нужно найти.
Шаг 2: Выясните, в какие единицы нужно перевести исходную величину (в большие или в меньшие).
Шаг 3: Если нужно перевести в меньшие единицы (например, ГБ в МБ), последовательно умножайте на 1024.
Шаг 4: Если нужно перевести в большие единицы (например, байты в КБ), последовательно делайте на 1024.
Шаг 5: Запишите полученный результат с указанием единиц измерения.

#-SLIDE-START-#
TITLE:: 3. Пошаговые методические указания по выполнению заданий
Задание 2: Расчет количества информации в сообщении
Шаг 1: Определите, сколько символов содержит сообщение. Не забывайте считать пробелы и все знаки препинания.
Шаг 2: Выясните из условия задачи, какой информационный вес у одного символа (например, 1 байт или 16 бит).
Шаг 3: Умножьте количество символов на информационный вес одного символа.
Шаг 4: Если требуется, переведите полученный результат в другие единицы измерения.
#-SLIDE-START-#
TITLE:: 4. Примеры решенных заданий
Пример 1: Перевод ГБ в КБ
Условие: Перевести 2 ГБ в килобайты.
Решение:
Сначала переводим гигабайты в мегабайты (умножаем):
2 ГБ * 1024 = 2048 МБ
Затем переводим мегабайты в килобайты (умножаем):
2048 МБ * 1024 = 2097152 КБ
Ответ: 2097152 КБ.
Пример 2: Расчет объема слова
Условие: Рассчитать информационный объем слова "Java", если каждый символ кодируется 8 битами. Ответ дать в байтах.
Решение:
Считаем количество символов в слове "Java": 4 символа.
Находим общий объем в битах: 4 символа * 8 бит/символ = 32 бита
Переводим биты в байты (делим на 8): 32 бита / 8 = 4 байта
Ответ: 4 байта.
#-SLIDE-START-#
TITLE:: 5. Комментарии к оформлению результатов
Четкость решения: Каждое задание должно содержать запись "Дано:", "Найти:", "Решение:" и "Ответ:".
Пояснения: Все математические операции должны сопровождаться краткими пояснениями.
Единицы измерения: Обязательно указывайте единицы измерения на каждом этапе вычислений и в итоговом ответе.
Формат сдачи: Работа оформляется в текстовом редакторе, сохраняется в формате .pdf.
Именование файла: Файл с работой должен быть назван по шаблону: Фамилия_Имя_ПР1.pdf.

##-TOPIC-START-##
Практическая работа №2: Кодирование и передача информации
#-SLIDE-START-#
TITLE:: 1. Цели и задачи выполнения практической работы
Цель: Сформировать практические навыки расчета информационного объема различных типов данных (текст, графика, звук) и времени их передачи по каналам связи.
Задачи:
Научиться рассчитывать объем текстовых файлов в различных кодировках.
Освоить формулу для расчета объема растрового изображения.
Познакомиться с принципами расчета объема аудиоданных.
Научиться применять формулу для расчета времени передачи файла.
#-SLIDE-START-#
TITLE:: 2. Краткое изложение теоретического материала
Кодирование текста:
ASCII: 1 символ = 1 байт = 8 бит.
Unicode (UTF-16): 1 символ = 2 байта = 16 бит.
Объем текста = Количество символов * Информационный вес 1 символа.
Кодирование растровой графики:
Объем изображения = Ширина (пикс) * Высота (пикс) * Глубина цвета (бит).
Глубина цвета (i) связана с количеством цветов в палитре (N) формулой: N = 2^i.
Кодирование звука:
Объем аудио = Частота дискретизации (Гц) * Глубина кодирования (бит) * Время (с) * Кол-во каналов.
Передача информации:
Время передачи (с) = Объем файла (бит) / Скорость канала (бит/с).
Необходимо следить за единицами измерения! 1 Мбит/с ≠ 1 Мбайт/с.
#-SLIDE-START-#
TITLE:: 3. Пошаговые методические указания по выполнению заданий
Задание 1: Определение размера текстового файла.
Шаг 1: Посчитайте общее количество символов в тексте.
Шаг 2: Определите информационный вес одного символа в указанной кодировке.
Шаг 3: Перемножьте количество символов на вес одного символа.
Задание 2: Расчет объема растрового изображения.
Шаг 1: Определите ширину и высоту изображения в пикселях.
Шаг 2: Найдите глубину цвета (i) из количества цветов в палитре (N) по формуле N = 2^i.
Шаг 3: Перемножьте ширину, высоту и глубину цвета.
Задание 4: Решение задач на пропускную способность канала.
Шаг 1: Приведите объем файла и скорость канала к единой единице измерения (биты и бит/с).
Шаг 2: Разделите объем файла на скорость канала.
#-SLIDE-START-#
TITLE:: 4. Примеры решенных заданий
Пример 1 (Изображение):
Условие: Рассчитать объем изображения 64x64 пикселя, если в палитре 256 цветов.
Решение:
N = 256, значит 256 = 2^i, отсюда i = 8 бит (глубина цвета).
Объем = 64 * 64 * 8 = 32768 бит.
Переводим в байты: 32768 / 8 = 4096 байт.
Переводим в КБ: 4096 / 1024 = 4 КБ.
Ответ: 4 КБ.
Пример 2 (Передача данных):
Условие: Скорость модема 51200 бит/с. Сколько времени в секундах займет передача файла объемом 100 КБ?
Решение:
Переводим объем файла в биты: 100 КБ * 1024 * 8 = 819200 бит.
Находим время: 819200 бит / 51200 бит/с = 16 с.
Ответ: 16 секунд.


##-TOPIC-START-##
Практическая работа №6: Введение в Java и первая программа
Модуль 2. Основы программирования на Java
#-SLIDE-START-#
TITLE:: 1. Цели и задачи выполнения практической работы
Цель: Настроить рабочее окружение и написать первую работающую программу на Java.
Задачи:
- установить и проверить работоспособность JDK.
- установить и познакомиться с интерфейсом IntelliJ IDEA.
- научиться создавать новый проект в IDE.
- освоить процесс написания, компиляции и запуска Java-программы.
#-SLIDE-START-#
TITLE:: 2. Краткое изложение теоретического материала
JDK (Java Development Kit): Комплект разработчика. Включает в себя компилятор (javac), стандартные библиотеки и среду выполнения (JRE). Необходим для написания программ.
IntelliJ IDEA: Интегрированная среда разработки (IDE), которая помогает писать код, компилировать и запускать его одной кнопкой.
Структура программы: Любая Java-программа состоит как минимум из одного класса. Точкой входа является метод public static void main(String[] args).
Вывод в консоль: Для вывода текста на экран используется команда System.out.println("Текст");.
#-SLIDE-START-#
TITLE:: 3. Пошаговые методические указания по выполнению заданий
Задания 1-2: Установка и настройка.
Шаг 1: Скачайте и установите JDK.
Шаг 2: Откройте командную строку и введите команды java -version и javac -version для проверки.
Шаг 3: Скачайте и установите IntelliJ IDEA Community Edition.
Задание 4: Написание и запуск программы.
Шаг 1: В IntelliJ IDEA создайте новый проект.
Шаг 2: В папке src создайте файл Main.java.
Шаг 3: Внутри файла напишите код "Hello, World!".
Шаг 4: Нажмите на зеленую стрелочку рядом с методом main и выберите "Run".
#-SLIDE-START-#
TITLE:: 4. Код "Hello, World!"
[CODE_BLOCK]
public class Main {
public static void main(String[] args) {
System.out.println("Hello, World!");
}
}
[/CODE_BLOCK]
В нижней части экрана в окне "Run" вы должны увидеть результат — строку "Hello, World!".
#-SLIDE-START-#
TITLE:: 5. Комментарии к оформлению результатов
В качестве отчета по данной работе приложите скриншоты:
Результат выполнения команды java -version в терминале.
Окно IntelliJ IDEA с вашим первым проектом и кодом.
Окно IntelliJ IDEA с результатом выполнения программы в консоли.

##-TOPIC-START-##
Практическая работа №7: Переменные и типы данных
#-SLIDE-START-#
TITLE:: 1. Цели и задачи выполнения практической работы
Цель: Научиться объявлять переменные, работать с основными типами данных и выполнять базовые арифметические операции.
Задачи:
Освоить синтаксис объявления переменных в Java.
Познакомиться с основными типами: int, double, String.
Научиться выполнять арифметические операции и конкатенацию строк.
Освоить базовый ввод данных с клавиатуры.
#-SLIDE-START-#
TITLE:: 2. Краткое изложение теоретического материала
Переменная: Именованная область в памяти для хранения данных. тип_данных имя_переменной;.
Основные типы:
int: для целых чисел (10, -5, 0).
double: для дробных чисел (3.14, -0.5).
String: для работы с текстом ("Привет").
Ввод с клавиатуры: Используется класс Scanner.
[CODE_BLOCK]
Scanner scanner = new Scanner(System.in);
int number = scanner.nextInt(); // Читает целое число
String line = scanner.nextLine(); // Читает строку
[/CODE_BLOCK]
Вывод: Для вывода значения переменной используется System.out.println(имя_переменной);.
#-SLIDE-START-#
TITLE:: 3. Пошаговые методические указания: Калькулятор сложения
Шаг 1: Создайте объект класса Scanner для чтения ввода.
Шаг 2: Выведите в консоль приглашение для пользователя ввести первое число.
Шаг 3: Прочитайте первое число в переменную типа int.
Шаг 4: Аналогично прочитайте второе число.
Шаг 5: Создайте третью переменную и сохраните в нее сумму первых двух.
Шаг 6: Выведите результат на экран.
#-SLIDE-START-#
TITLE:: 4. Пример: Программа-приветствие
[CODE_BLOCK]
import java.util.Scanner;
public class Greeting {
public static void main(String[] args) {
Scanner scanner = new Scanner(System.in);
Generated code
     System.out.print("Введите ваше имя: ");
    String name = scanner.nextLine();

    System.out.println("Привет, " + name + "!");
}
   
}
[/CODE_BLOCK]
Результат в консоли (пример диалога):
Введите ваше имя: Мария
Привет, Мария!

##-TOPIC-START-##
Модуль 3. Основы объектно-ориентированного программирования (ООП)

Практическая работа №11: Классы и объекты
#-SLIDE-START-#
TITLE:: 1. Цели и задачи выполнения практической работы
Цель: Освоить фундаментальные понятия ООП: класс и объект.
Задачи:
Научиться проектировать и создавать простые классы для описания сущностей реального мира.
Научиться создавать экземпляры классов (объекты).
Отработать навык доступа к полям объекта и их изменения.
#-SLIDE-START-#
TITLE:: 2. Краткое изложение теоретического материала
Класс: Шаблон или "чертеж" для создания объектов. Описывает, какие поля (характеристики) и методы (действия) будут у объектов этого типа. Объявляется с помощью ключевого слова class.
Объект (экземпляр): Конкретная реализация класса, существующая в памяти. Создается с помощью оператора new.
Поле: Переменная внутри класса, описывающая его состояние или свойство.
Доступ к полям: Осуществляется через точку: имя_объекта.имя_поля.
#-SLIDE-START-#
TITLE:: 3. Пошаговые методические указания по выполнению заданий
Задание 1: Создание класса User.
Шаг 1: Создайте новый Java-файл User.java.
Шаг 2: Внутри файла объявите класс: public class User { }.
Шаг 3: Внутри класса объявите два поля: public String login; и public int age;.
Задание 2: Создание и использование объектов.
Шаг 1: В методе main создайте первый объект: User user1 = new User();.
Шаг 2: Присвойте значения его полям: user1.login = "admin"; и user1.age = 30;.
Шаг 3: Аналогично создайте второй объект user2 с другими данными.
Шаг 4: Выведите на экран значения полей обоих объектов.
#-SLIDE-START-#
TITLE:: 4. Пример: Класс "Автомобиль"
[CODE_BLOCK]
// Файл Car.java
public class Car {
public String model;
public int year;
}
// Файл Main.java
public class Main {
public static void main(String[] args) {
Car car1 = new Car();
car1.model = "Lada Vesta";
car1.year = 2021;
System.out.println("Модель: " + car1.model + ", Год: " + car1.year);
}
}
[/CODE_BLOCK]
Результат в консоли:
Модель: Lada Vesta, Год: 2021



##-TOPIC-START-##
Практическая работа №16: Основы Git
Модуль 5. Работа с git
#-SLIDE-START-#
TITLE:: 1. Цели и задачи выполнения практической работы
Цель: Освоить базовый рабочий цикл в системе контроля версий Git.
Задачи:
Научиться инициализировать репозиторий.
Освоить добавление файлов в индекс и создание коммитов.
Научиться создавать ветки, переключаться между ними и сливать их.
Освоить команды для просмотра истории и текущих изменений.
#-SLIDE-START-#
TITLE:: 2. Краткое изложение теоретического материала
Репозиторий: "Хранилище" вашего проекта, содержащее все файлы и полную историю их изменений.
Рабочий цикл:
Изменение файлов.
Индексация (git add): добавление изменений в "область подготовки" к коммиту.
Коммит (git commit): сохранение индексированных изменений в истории репозитория.


Ветка (branch): Параллельная линия разработки. Позволяет работать над новой задачей, не затрагивая основную ветку main.
Слияние (merge): Процесс объединения изменений из одной ветки в другую.
#-SLIDE-START-#
TITLE:: 3. Пошаговые методические указания по выполнению заданий
Задание 1: Установка и конфигурация.
Шаг 1: Установите Git с официального сайта.
Шаг 2: Откройте терминал и выполните команды для настройки:
[CODE_BLOCK]
git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"
[/CODE_BLOCK]
Задание 2: Создание репозитория и коммитов.
Шаг 1: Создайте новую папку для проекта, зайдите в нее через терминал.
Шаг 2: Выполните git init.
Шаг 3: Создайте файл file1.txt, добавьте в него текст.
Шаг 4: Выполните git add file1.txt, а затем git commit -m "Add first file".
Задание 3: Работа с ветками.
Шаг 1: Создайте новую ветку: git branch new-feature.
Шаг 2: Переключитесь на нее: git checkout new-feature.
Шаг 3: Измените file1.txt, сделайте add и commit.
Шаг 4: Вернитесь на основную ветку: git checkout main.
Шаг 5: Выполните слияние: git merge new-feature.
#-SLIDE-START-#
TITLE:: 4. Просмотр истории и изменений
Просмотр истории коммитов: git log
Просмотр истории в одну строку: git log --oneline
Просмотр несохраненных изменений: git diff
Пример результата git log --oneline:
[CODE_BLOCK]
a1b2c3d (HEAD -> main) Merge branch 'new-feature'
e4f5g6h Add new feature
i7j8k9l Add first file
[/CODE_BLOCK]
#-SLIDE-START-#
TITLE:: 5. Комментарии к оформлению результатов
Для каждого задания предоставьте скриншот терминала с введенной командой и ее результатом.
Опишите своими словами, что делает каждая выполненная вами команда.



##-FOLDER-START-##
Базовый
##-TOPIC-START-##
Уровень: Базовый
Модуль 1. Продвинутые концепции ООП
Практическая работа №1: Инкапсуляция и геттеры/сеттеры
#-SLIDE-START-#
TITLE:: 1. Цели и задачи
Цель: Научиться защищать внутреннее состояние объекта от некорректных данных с помощью логики валидации.
Задачи:
Закрепить использование private полей.
Реализовать публичные сеттеры для изменения private полей.
Добавить в сеттеры условные конструкции (if) для проверки входящих данных.
Научиться выбрасывать исключение IllegalArgumentException в случае некорректных данных.
#-SLIDE-START-#
TITLE:: 2. Краткая теория
Инкапсуляция позволяет скрыть данные объекта, предоставив для их изменения специальные методы — сеттеры. Внутри сеттера, перед тем как присвоить новое значение полю, можно и нужно проверять это значение на корректность. Если данные неверны (например, отрицательная сумма пополнения), программа должна сообщить об ошибке, выбросив исключение. IllegalArgumentException — стандартное исключение для таких случаев.
#-SLIDE-START-#
TITLE:: 3. Методические указания: Валидация в сеттере
Шаг 1: Создайте класс BankAccount с приватным полем private double balance;.
Шаг 2: Создайте публичный метод-сеттер public void deposit(double amount).
Шаг 3: Внутри метода deposit добавьте проверку: if (amount <= 0).
Шаг 4: Если условие истинно, выбросьте исключение: throw new IllegalArgumentException(...).
Шаг 5: Если условие ложно, выполните операцию: this.balance += amount;.
Шаг 6: В методе main проверьте работу: вызовите метод с корректным и некорректным значением, обернув вызовы в try-catch.
#-SLIDE-START-#
TITLE:: 4. Пример решенного задания
[CODE_BLOCK]
// Фрагмент класса BankAccount
public void deposit(double amount) {
if (amount <= 0) {
throw new IllegalArgumentException("Сумма пополнения не может быть отрицательной или равной нулю.");
}
this.balance += amount;
System.out.println("Счет пополнен на " + amount);
}
// Фрагмент main
try {
account.deposit(-100);
} catch (IllegalArgumentException e) {
System.out.println("Ошибка: " + e.getMessage());
}
[/CODE_BLOCK]
Нужно предоставить код класса BankAccount и класса Main с демонстрацией вызова.
##-TOPIC-START-##
Практическая работа №3: Переопределение и перегрузка методов
#-SLIDE-START-#
TITLE:: 1. Цели и задачи
Цель: Научиться изменять поведение унаследованных методов в дочерних классах для реализации полиморфизма.
Задачи:
Создать базовый класс с методом, описывающим общее поведение.
Создать дочерний класс.
В дочернем классе переопределить родительский метод, предоставив специфичную реализацию.
Использовать аннотацию @Override для контроля корректности переопределения.
#-SLIDE-START-#
TITLE:: 2. Краткая теория
Переопределение (Overriding) позволяет дочернему классу предоставить собственную реализацию для унаследованного метода. Сигнатура метода (имя и параметры) должна полностью совпадать. Аннотация @Override не является обязательной, но крайне рекомендуется, так как она заставляет компилятор проверить, действительно ли вы переопределяете существующий метод, а не создаете новый из-за опечатки.
#-SLIDE-START-#
TITLE:: 3. Методические указания: Переопределение makeSound()
Шаг 1: Создайте класс Animal с методом public void makeSound(), который выводит "Животное издает звук".
Шаг 2: Создайте класс Dog extends Animal.
Шаг 3: В классе Dog над объявлением метода makeSound() поставьте аннотацию @Override.
Шаг 4: В теле метода напишите System.out.println("Собака лает: Гав-гав!");.
Шаг 5: В методе main создайте объект Dog и вызовите у него метод makeSound().
#-SLIDE-START-#
TITLE:: 4. Пример решенного задания
[CODE_BLOCK]
// Файл Animal.java
public class Animal {
public void makeSound() {
System.out.println("Некое животное издает звук.");
}
}
// Файл Dog.java
public class Dog extends Animal {
@Override
public void makeSound() {
System.out.println("Собака лает!");
}
}
[/CODE_BLOCK]
Попробуйте намеренно сделать опечатку в имени переопределяемого метода и приложите скриншот ошибки компиляции, которую покажет IDE благодаря @Override.



##-TOPIC-START-##
Модуль 2. Работа со строками
Практическая работа №5: Создание строк и неизменяемость
#-SLIDE-START-#
TITLE:: 1. Цели и задачи
Цель: Понять фундаментальное различие между сравнением ссылок и сравнением содержимого объектов в Java.
Задачи:
Создать строки разными способами.
Применить оператор == для сравнения ссылок на объекты.
Применить метод .equals() для сравнения содержимого строк.
Проанализировать и объяснить полученные результаты.
#-SLIDE-START-#
TITLE:: 2. Краткая теория
==: Сравнивает, указывают ли две переменные на один и тот же объект в памяти.
.equals(): Сравнивает внутреннее содержимое объектов. Для строк он проверяет, совпадают ли последовательности символов.
String Pool: Java оптимизирует хранение строковых литералов. Если вы создаете две одинаковые строки-литерала (String s1 = "Hi"; String s2 = "Hi";), они будут ссылаться на один и тот же объект в специальной области памяти (String Pool). Создание строки через new String("Hi") всегда создает новый объект в основной памяти (heap).
#-SLIDE-START-#
TITLE:: 3. Методические указания: Сравнение строк
Шаг 1: Создайте три строковые переменные:
[CODE_BLOCK]
String a = "hello";
String b = "hello";
String c = new String("hello");
[/CODE_BLOCK]
Шаг 2: Выполните и выведите в консоль результаты трех сравнений с помощью ==: a == b, a == c, b == c.
Шаг 3: Выполните и выведите в консоль результаты трех сравнений с помощью .equals(): a.equals(b), a.equals(c), b.equals(c).
Шаг 4: Напишите в комментариях к коду, почему результаты a == b и a == c разные.
#-SLIDE-START-#
TITLE:: 4. Пример решенного задания
[CODE_BLOCK]
String s1 = "Java"; // Помещается в String Pool
String s2 = "Java"; // Ссылка на тот же объект в пуле
String s3 = new String("Java"); // Новый объект в heap
System.out.println("s1 == s2: " + (s1 == s2)); // true, т.к. ссылаются на один объект
System.out.println("s1 == s3: " + (s1 == s3)); // false, т.к. ссылаются на разные объекты
System.out.println("s1.equals(s3): " + s1.equals(s3)); // true, т.к. содержимое одинаковое
[/CODE_BLOCK]
Обязательно добавьте текстовое объяснение полученных true/false результатов.


##-TOPIC-START-##
Модуль 3. Коллекции, обобщения (Generics), Comparable и сортировка
Практическая работа №7: Использование HashSet
#-SLIDE-START-#
TITLE:: 1. Цели и задачи
Цель: Понять "контракт" между equals() и hashCode() и его важность для корректной работы хеш-коллекций.
Задачи:
Создать пользовательский класс.
Переопределить в нем методы equals() и hashCode().
Продемонстрировать, как HashSet обрабатывает дубликаты объектов этого класса.
Проанализировать, что произойдет, если hashCode() реализован неверно.
#-SLIDE-START-#
TITLE:: 2. Краткая теория: Контракт equals-hashCode
Если a.equals(b) возвращает true, то a.hashCode() обязан быть равен b.hashCode().
Если a.hashCode() не равен b.hashCode(), то a.equals(b) обязан возвращать false.
HashSet для определения уникальности сначала проверяет hashCode(). Если хеш-коды разные, объекты точно разные. Если хеш-коды одинаковые, он дополнительно вызывает .equals() для окончательной проверки. Если нарушить контракт, HashSet будет работать некорректно.
#-SLIDE-START-#
TITLE:: 3. Методические указания: HashSet и пользовательский класс
Шаг 1: Создайте класс Student с полями id и name.
Шаг 2: С помощью вашей IDE сгенерируйте для него методы equals() и hashCode(), выбрав для участия в сравнении оба поля.
Шаг 3: Создайте HashSet<Student>.
Шаг 4: Создайте два разных объекта Student с одинаковыми данными:
[CODE_BLOCK]
Student s1 = new Student(1, "Иван");
Student s2 = new Student(1, "Иван");
[/CODE_BLOCK]
Шаг 5: Добавьте оба объекта в Set (students.add(s1);, students.add(s2);).
Шаг 6: Выведите размер сета (students.size()). Он должен быть равен 1.
#-SLIDE-START-#
TITLE:: 4. Пример решенного задания: equals() и hashCode()
[CODE_BLOCK]
// В классе Student
@Override
public boolean equals(Object o) {
if (this == o) return true;
if (o == null || getClass() != o.getClass()) return false;
Student student = (Student) o;
return id == student.id && Objects.equals(name, student.name);
}
@Override
public int hashCode() {
return Objects.hash(id, name);
}
[/CODE_BLOCK]
В качестве эксперимента закомментируйте метод hashCode() и посмотрите, что изменится (размер сета станет 2). Опишите в отчете, почему это произошло.

##-FOLDER-START-##
Продвинутый
##-TOPIC-START-##
Практическая работа: Основы синхронизации и проблемы многопоточности
Уровень: Продвинутый
Модуль 1. Многопоточность и потоки ввода-вывода
#-SLIDE-START-#
TITLE:: 1. Цели и задачи
Цель: Сформировать практические навыки написания потокобезопасного кода и решения классических проблем многопоточности в Java.
Задачи:
Научиться на практике выявлять и демонстрировать проблему "состояния гонки" (race condition).
Освоить применение ключевого слова synchronized для обеспечения атомарности операций.
Научиться использовать классы из пакета java.util.concurrent.atomic (на примере AtomicInteger).
Сравнить производительность различных подходов к синхронизации.
#-SLIDE-START-#
TITLE:: 2. Краткая теория
Race Condition (Состояние гонки): Ошибка, возникающая, когда несколько потоков одновременно обращаются к общему ресурсу, и как минимум один из потоков его изменяет. Итоговый результат зависит от случайного порядка выполнения потоков.
synchronized: Ключевое слово, которое позволяет ограничить доступ к блоку кода или методу. Только один поток может выполнять synchronized блок на одном и том же объекте-мониторе в один момент времени.
AtomicInteger: Класс, предоставляющий методы для атомарных операций над примитивами (например, incrementAndGet()). Работает на основе неблокирующих lock-free алгоритмов. В условиях высокой конкуренции производительнее, чем synchronized.
#-SLIDE-START-#
TITLE:: 3. Методические указания: BankAccount
Шаг 1 (Небезопасный класс): Создайте класс BankAccount с полем private long balance и методами deposit() и withdraw(), которые просто изменяют баланс.
Шаг 2 (Потоки): В main создайте один экземпляр BankAccount и ExecutorService.
Шаг 3 (Операции): В цикле запустите 1000 задач на пополнение и 1000 задач на снятие.
Шаг 4 (Проверка): Завершите работу ExecutorService и выведите итоговый баланс. Он не будет равен нулю из-за race condition.
Шаг 5 (Решение): Добавьте ключевое слово synchronized к сигнатурам методов deposit и withdraw.
Шаг 6 (Повторная проверка): Запустите программу еще раз и убедитесь, что итоговый баланс теперь всегда равен нулю.
#-SLIDE-START-#
TITLE:: 4. Примеры решенных заданий
Пример 1: Фрагмент решения для BankAccount
Небезопасный метод:
[CODE_BLOCK]
public void deposit(long amount) {
balance = balance + amount;
}
[/CODE_BLOCK]
Потокобезопасный метод:
[CODE_BLOCK]
public synchronized void deposit(long amount) {
balance = balance + amount;
}
[/CODE_BLOCK]
Пример 2: Класс CounterAtomic
[CODE_BLOCK]
import java.util.concurrent.atomic.AtomicInteger;
class CounterAtomic {
private AtomicInteger count = new AtomicInteger(0);
Generated code
     public void increment() {
    count.incrementAndGet();
}
public int getValue() {
    return count.get();
}
   
IGNORE_WHEN_COPYING_START
content_copy download
Use code with caution.
IGNORE_WHEN_COPYING_END
}
[/CODE_BLOCK]



##-TOPIC-START-##
Модуль 2. Продвинутые интеграции и инструменты
Практическая работа №22: Основы работы с базами данных (JDBC)
#-SLIDE-START-#
TITLE:: 1. Цели и задачи
Цель: Научиться взаимодействовать с реляционными базами данных из Java-приложения с помощью стандартного API JDBC.
Задачи:
Освоить процесс настройки подключения к базе данных.
Научиться выполнять SQL-запросы (SELECT, UPDATE) и обрабатывать их результаты.
Освоить использование PreparedStatement для безопасной передачи параметров в запрос.
#-SLIDE-START-#
TITLE:: 2. Краткая теория
JDBC (Java Database Connectivity): Стандартный Java API для работы с БД.
Основные шаги:
Установить соединение: Connection conn = DriverManager.getConnection(...).
Создать запрос: Statement или PreparedStatement.
Выполнить запрос: executeQuery() (для SELECT) или executeUpdate() (для INSERT, UPDATE, DELETE).
Обработать результат: ResultSet — это итератор по строкам ответа.
Закрыть ресурсы: ResultSet, Statement, Connection. Лучше всего это делать с помощью try-with-resources.
PreparedStatement: Используется для параметризованных запросов с плейсхолдерами ? для защиты от SQL-инъекций.
#-SLIDE-START-#
TITLE:: 3. Методические указания
Задание 1: SELECT
Шаг 1: Добавьте в зависимости проекта JDBC-драйвер для вашей БД.
Шаг 2: В блоке try-with-resources установите соединение с БД.
Шаг 3: Внутри создайте Statement и выполните SELECT * FROM ....
Шаг 4: В цикле while обойдите ResultSet и выведите данные в консоль.
Задание 2: UPDATE с параметрами.
Шаг 1: Установите соединение.
Шаг 2: Создайте PreparedStatement с SQL-запросом UPDATE ... SET ... WHERE id = ?.
Шаг 3: Установите параметры с помощью методов setString(), setInt() и т.д.
Шаг 4: Выполните запрос с помощью executeUpdate().
#-SLIDE-START-#
TITLE:: 4. Пример: Получение имени пользователя по ID
[CODE_BLOCK]
String sql = "SELECT name FROM users WHERE id = ?";
try (Connection conn = DriverManager.getConnection(URL, USER, PASS);
PreparedStatement pstmt = conn.prepareStatement(sql)) {
Generated code
     pstmt.setInt(1, 101); // Устанавливаем ID пользователя
ResultSet rs = pstmt.executeQuery();

if (rs.next()) {
    String name = rs.getString("name");
    System.out.println("Имя пользователя: " + name);
}
   
IGNORE_WHEN_COPYING_START
content_copy download
Use code with caution.
IGNORE_WHEN_COPYING_END
} catch (SQLException e) {
e.printStackTrace();
}
[/CODE_BLOCK]
Приложите SQL-скрипт для создания таблицы, с которой вы работали.

##-TOPIC-START-##
Практическая работа №28: Работа с базами данных: Spring и JPA
Модуль 3. Основы Spring Framework
#-SLIDE-START-#
TITLE:: 1. Цели и задачи
Цель: Научиться эффективно взаимодействовать с реляционными базами данных, используя высокоуровневые абстракции Spring Data JPA.
Задачи:
Настроить подключение к базе данных в Spring-приложении.
Научиться описывать таблицы БД с помощью JPA-сущностей (@Entity).
Освоить создание и использование JpaRepository для выполнения CRUD-операций без написания SQL-кода.
#-SLIDE-START-#
TITLE:: 2. Краткая теория
ORM (Object-Relational Mapping): Технология, которая "связывает" объекты Java с записями в таблицах баз данных.
JPA (Java Persistence API): Стандартная спецификация для ORM в Java.
@Entity: Аннотация, которая помечает класс как JPA-сущность.
@Id: Аннотация для поля, которое является первичным ключом.
@GeneratedValue: Указывает, что значение первичного ключа должно генерироваться автоматически.
Spring Data JPA: Модуль Spring, который максимально упрощает создание слоя доступа к данным.
JpaRepository<T, ID>: Интерфейс, который нужно унаследовать, чтобы получить полный набор готовых CRUD-методов.
#-SLIDE-START-#
TITLE:: 3. Методические указания
Задание 1: Настройка подключения к БД.
Шаг 1: Добавьте зависимости spring-boot-starter-data-jpa и JDBC-драйвер.
Шаг 2: В application.properties пропишите настройки для подключения: spring.datasource.url, username, password.
Шаг 3: Добавьте spring.jpa.hibernate.ddl-auto=update, чтобы Hibernate автоматически создавал/обновлял таблицы.
Задание 2: Создание JPA-сущности.
Шаг 1: Создайте POJO-класс (например, Product).
Шаг 2: Пометьте его аннотацией @Entity.
Шаг 3: Добавьте поле private Long id; и пометьте его аннотациями @Id и @GeneratedValue.
Задание 3: Создание и использование репозитория.
Шаг 1: Создайте интерфейс ProductRepository extends JpaRepository<Product, Long>.
Шаг 2: В ProductService внедрите ваш репозиторий: @Autowired private ProductRepository repository;.
Шаг 3: В методах сервиса используйте готовые методы репозитория: repository.save(), repository.findById(), repository.findAll(), repository.deleteById().
#-SLIDE-START-#
TITLE:: 4. Пример: Интерфейс репозитория и его использование
[CODE_BLOCK]
// Файл ProductRepository.java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
// Здесь можно добавлять кастомные методы, например:
// List<Product> findByPriceGreaterThan(double price);
}
// Фрагмент ProductService.java
@Service
public class ProductService {
@Autowired
private ProductRepository repository;
Generated code
     public Product createProduct(Product product) {
    return repository.save(product);
}
   
IGNORE_WHEN_COPYING_START
content_copy download
Use code with caution.
IGNORE_WHEN_COPYING_END
}
[/CODE_BLOCK]



##-TOPIC-START-##
Практическая работа №31: Введение в Spring Boot
Модуль 4. Быстрая разработка на Spring Boot
#-SLIDE-START-#
TITLE:: 1. Цели и задачи
Цель: Освоить основы Spring Boot и научиться быстро создавать и запускать готовые к работе веб-приложения.
Задачи:
Научиться генерировать стартовый шаблон проекта с помощью Spring Initializr.
Понять роль аннотации @SpringBootApplication и механизма автоконфигурации.
Создать простой REST-контроллер и запустить приложение на встроенном веб-сервере.
#-SLIDE-START-#
TITLE:: 2. Краткая теория
Spring Boot: Надстройка над Spring Framework, которая следует принципу "соглашение вместо конфигурации".
Spring Initializr (start.spring.io): Веб-инструмент для генерации "скелета" проекта с нужными зависимостями.
"Стартеры" (spring-boot-starter-*): Наборы зависимостей, которые "включают" определенную функциональность (например, spring-boot-starter-web для веб-приложений).
Автоконфигурация: Spring Boot анализирует подключенные стартеры и автоматически настраивает все необходимые бины.
@SpringBootApplication: Главная аннотация, которая объединяет в себе @Configuration, @EnableAutoConfiguration и @ComponentScan.
#-SLIDE-START-#
TITLE:: 3. Методические указания
Задание 1: Создание проекта через Spring Initializr.
Шаг 1: Перейдите на сайт start.spring.io.
Шаг 2: Выберите Maven, Java, актуальную версию Spring Boot.
Шаг 3: Задайте метаданные проекта (Group, Artifact).
Шаг 4: В "Dependencies" добавьте Spring Web и Spring Boot DevTools.
Шаг 5: Нажмите "Generate", скачайте, распакуйте и откройте проект в IDE.
Задание 2: Первый запуск.
Шаг 1: Найдите главный класс с аннотацией @SpringBootApplication.
Шаг 2: Запустите его как обычное Java-приложение (через метод main).
Шаг 3: В логах вы увидите запуск сервера Tomcat на порту 8080.
Задание 3: Создание REST-контроллера.
Шаг 1: Создайте класс GreetingController с аннотацией @RestController.
Шаг 2: Внутри создайте метод, аннотированный @GetMapping("/greet"), который возвращает строку.
Шаг 3: Перезапустите приложение и откройте в браузере http://localhost:8080/greet.
#-SLIDE-START-#
TITLE:: 4. Пример: Простейший REST-контроллер
[CODE_BLOCK]
@RestController
public class GreetingController {
Generated code
     @GetMapping("/api/v1/hello")
public String sayHello() {
    return "Greetings from the server!";
}
   
IGNORE_WHEN_COPYING_START
content_copy download
Use code with caution.
IGNORE_WHEN_COPYING_END
}
[/CODE_BLOCK]
Приложите скриншот браузера или Postman, демонстрирующий успешный запрос к вашему эндпоинту.
##-TOPIC-START-##
Практическая работа №35: Тестирование в Spring Boot
#-SLIDE-START-#
TITLE:: 1. Цели и задачи
Цель: Научиться писать автоматические тесты для различных слоев Spring Boot приложения.
Задачи:
Написать юнит-тест для сервисного слоя с мокированием зависимостей.
Написать "срезанный" интеграционный тест для REST-контроллера с использованием MockMvc.
Написать интеграционный тест для слоя репозиториев с использованием @DataJpaTest.
#-SLIDE-START-#
TITLE:: 2. Краткая теория
spring-boot-starter-test: Стартер, который добавляет библиотеки для тестирования (JUnit 5, Mockito).
@SpringBootTest: Аннотация для полного интеграционного теста (медленная).
@WebMvcTest(Controller.class): Аннотация для тестирования только веб-слоя. Не поднимает сервисы.
@DataJpaTest: Аннотация для тестирования только слоя JPA. Настраивает встроенную БД в памяти.
Мокирование (@MockBean): Аннотация Spring Boot, которая создает "заглушку" (мок) для бина. Позволяет задать поведение мока и изолировать тестируемый компонент от его зависимостей.
#-SLIDE-START-#
TITLE:: 3. Методические указания
Задание 1: Тестирование сервиса.
Шаг 1: Создайте тестовый класс MyServiceTest.
Шаг 2: Замокайте зависимости сервиса (например, репозиторий) с помощью @Mock.
Шаг 3: В тестовом методе (@Test) задайте поведение мока с помощью Mockito.when(...).thenReturn(...).
Шаг 4: Вызовите тестируемый метод сервиса и проверьте результат с помощью Assertions.assertEquals(...).
Задание 2: Тестирование контроллера.
Шаг 1: Создайте класс MyControllerTest с аннотацией @WebMvcTest(MyController.class).
Шаг 2: Внедрите MockMvc с помощью @Autowired.
Шаг 3: Замокайте сервисный слой с помощью @MockBean.
Шаг 4: С помощью mockMvc.perform(get("/my-url")) выполните "ненастоящий" HTTP-запрос и проверьте результат с помощью .andExpect(status().isOk()).
#-SLIDE-START-#
TITLE:: 4. Пример: Тест для контроллера с MockMvc
[CODE_BLOCK]
@WebMvcTest(ProductController.class)
class ProductControllerTest {
Generated code
     @Autowired
private MockMvc mockMvc;

@MockBean
private ProductService productService;

@Test
void shouldReturnProductById() throws Exception {
    Product product = new Product(1L, "Test Product", 99.99);
    when(productService.findById(1L)).thenReturn(product);

    mockMvc.perform(get("/products/1"))
           .andExpect(status().isOk())
           .andExpect(jsonPath("$.name").value("Test Product"));
}
   
IGNORE_WHEN_COPYING_START
content_copy download
Use code with caution.
IGNORE_WHEN_COPYING_END
}
[/CODE_BLOCK]
Приложите скриншот из IDE, демонстрирующий успешное прохождение всех тестов (зеленые галочки).

